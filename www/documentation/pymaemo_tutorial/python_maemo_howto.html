<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>Using Python in maemo</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" type="text/css" href="style.css">
  <script type="text/javascript" src="scripts.js"></script>
</head>
<body>

<h1>Using Python in maemo</h1>
<div class="copyright">
  <p>
    Copyright &copy; 2006-2007 INdT - Instituto Nokia de Tecnologia
    <br>
    Copyright &copy; 2007 Nokia Corporation
    <br>
    Author: Daniel d'Andrada T. de Carvalho &lt;daniel.[last name] at indt.org.br&gt;
  </p>
</div>

<div id="minitoc-area" class="minitoc-area">
<!-- Write/use a TOC generator and put the generated HTML code here. -->
</div>



<h2>Introduction</h2>
<div class="section">
  <p>
    This document explains how to develop applications for the maemo platform using the Python
    programming language. To use the document, you must have a basic knowledge of
    <a href="http://www.python.org/">Python</a> and <a href="http://www.pygtk.org/">PyGTK</a>
    (advanced knowledge is not required, but you must be able to write simple GTK programs in
    Python).
  </p>
</div>



<h2>Prerequisites</h2>
<div class="section">
  <p>
    Before you start to write your own Python applications for maemo, perform the following tasks:
  </p>
  <ul>
    <li>
      Learn the basics of the maemo platform
      <p>
        For more information, see the <em>Overview of the Maemo Platform</em> section in <em>Maemo 3.0 Tutorial</em>
        <a href="#references_maemo_sdk_tutorial"><sup>1</sup></a>.
      </p>
    </li>
    <li>
      Set up the maemo development environment
      <p>
        The maemo development environment is where you run your maemo applications. For more
        information, see <em>Setting Up and Testing Development Environment</em> section in <em>Maemo 3.0
        Tutorial</em><a href="#references_maemo_sdk_tutorial"><sup>1</sup></a>. The tutorial assumes
        that you are developing from Scratchbox instead of directly using a maemo device (such as
        a Nokia 770).
      </p>
    </li>
  </ul>
</div>



<h2>Python limitations in maemo</h2>
<div class="section">
  <p>
    As handheld devices have limited resources (when compared to desktop or notebook computers),
    several modules have been removed from maemo's Python in order to reduce its footprint.
  </p>
  <p>The following modules have been removed:</p>
  <p>
    test, ctypes/test, sqlite3/test, email/test, _ctypes_test.so, _testcapi.so, linuxaudiodev.so,
    ossaudiodev.so, audioop.so, lib-tk, bsddb, idlelib.
  </p>
  <p>The following modules have been removed but are supplied by other modules:</p>
  <p>pyexpat.so, xmldom, xmlsax, xmlparsers.</p>
  <p>The following modules are deprecated:</p>
  <p>
    dbhash, curses, posixfile, getpass, macpath, macurl2path, os2emxpath, nturl2path, pty, pyclbr,
    rexec, rlcompleter, statvfs, stringold, telnetlib, this, toaiff, tty, user, xdrlib, aifc,
    audiodev, sunaudio and sunau.
  </p>
  <p>The following modules are only available in the SDK:</p>
  <p>
    distutils, pdb, pydoc, BaseHTTPServer, SimpleHTTPServer, SimpleXMLRPCServer, CGIHTTPServer,
    cgi, cgitb, DocXMLRPCServeri, robotparser, smtpd, compile, encodings.cp*, encodings.mac*,
    doctest, unittest, config, symtable, tabnanny, timeit, trace and hotshot.
  </p>
  <p>
    The <var>import</var> command will import <var>.pyo</var> files even if the interpreted is
    called without the <var>-O</var> or <var>-OO</var> option. This is a difference from the standard Python
    behavior.
  </p>
</div>



<h2>Installing Python</h2>
<div class="section">
  <p>
    Unfortunately, maemo SDK and maemo devices (Nokia 770 and N800, so far) doesn't come
    Python-ready out of the box. But the good news is that it's pretty easy to install Python on them.
  </p>

  <h3>On maemo SDK (scratchbox)</h3>
  <p>
    Follow the instructions on <var><a href="http://pymaemo.garage.maemo.org/sdk_installation.html">http://pymaemo.garage.maemo.org/sdk_installation.html</a></var>.
  </p>

  <h3>On maemo devices</h3>
  <p>
    The easiest way is to visit <var><a href="http://pymaemo.garage.maemo.org/installation.html">http://pymaemo.garage.maemo.org/installation.html</a></var>
    using the maemo device itself and clicking on the installation buttons there. If for some reason
    this is not possible or you like to install it by yourself there's also directions for manual
    installation on <var><a href="http://pymaemo.garage.maemo.org/manual_installation.html">http://pymaemo.garage.maemo.org/manual_installation.html</a></var>.
  </p>
</div>



<h2>Example of a "Hello World!" application</h2>
<div class="section">
  <p>
    To get started with Python, use the following sections to write a simple GTK+ application which
    creates and shows a window with a "Hello World!" text.
  </p>

  <h3>Plain PyGTK</h3>
  <p>Create a <var>hello_world_1.py</var> file with the following content.</p>
  <pre>
#!/usr/bin/env python2.5
import gtk

window = gtk.Window(gtk.WINDOW_TOPLEVEL)

label = gtk.Label("Hello World!")
window.add(label)

label.show()
window.show()

gtk.main()</pre>
  <p>
    In the Scratchbox console, first make the file executable by running the
    <var>chmode +x ./hello_world_1.py</var> command, and then run the file with the
    <var>run-standalone.sh ./hello_world_1.py</var> command. Figure 1 illustrates the results of
    the run command:
  </p>
  <div class="screenshot">
    <img alt="Plain PyGTK &quot;Hello World!&quot; application" src="images/hello_world_1_small.jpg">
    <p>Figure 1. Plain PyGTK "Hello World!" application</p>
  </div>
  <p>
    You can see that the plain PyGTK code already "works" on maemo. However, do not use plain
    PyGTK code or rely on the assumption that any PyGTK code "works" on maemo. In this tiny
    example program, the obvious sign of misfit in the maemo environment is that its borders
    (skin graphic area) are broken (look at the top corners).
  </p>
  <p>
    The reason for using the <var>run-standalone.sh</var> command to execute
    the application is that it adds the Hildon theming. Figure 2 illustrates how the application
    looks if run without the <var>run-standalone.sh</var> command:
  </p>
  <div class="screenshot">
    <img alt="Application without the Hildon theme" src="images/hello_world_1_no_theme_small.jpg">
    <p>Figure 2. Application without the Hildon theme</p>
  </div>
  <div class="note">
    <div class="label">Note</div>
    <div class="content">
      The <var>run-standalone.sh</var> command is only available if you run
      applications from the Scratchbox console.
    </div>
  </div>

  <h3>HildonWindow Class</h3>
  <p>
    The <var>HildonWindow</var> class overloads the <var>GtkWindow</var> class, providing the Hildon
    theme (look and feel) for top level windows. In order to use the facilities provided by the
    Hildon framework (and to integrate cleanly in it), the application must use a <var>HildonWindow</var>
    instead of a <var>GtkWindow</var>. With a <var>HildonWindow</var> class the application has,
    for example, access to Hildon menus and toolbars.
  </p>
  <p>
    The required code change is simple: replace the <var>GtkWindow</var> with <var>HildonWindow</var>
    and import the <var>hildon</var> module. The following example illustrates the required
    changes (also downloadable <a href="examples/hello_world_1.py">here</a>):
  </p>
  <pre>
#!/usr/bin/env python2.5

import gtk 
import hildon

window = hildon.Window()
window.connect("destroy", gtk.main_quit)
label = gtk.Label("Hello World!")
window.add(label)

label.show()
window.show()

gtk.main()</pre>
  <div class="screenshot">
    <img alt="Hildon-compliant &quot;Hello World!&quot; application" src="images/hello_world_3_small.jpg">
    <p>Figure 3. Hildon-compliant "Hello World!" application</p>
  </div>
  <p>
    Note how the borders are now drawn in the right way, since the program is using the
    <var>HildonWindow</var> class.
  </p>

  <h3>HildonProgram Class</h3>
  <p>
    The <var>HildonProgram</var> class is a programmer commodity used to apply program-wide settings
    to all Hildon windows used by the application (for example, this allows you to have a common
    menu and toolbar on all windows). In addition, <var>HildonProgram</var> also manages other
    program-wide issues, such as hibernating.
  </p>
  <p>
    The example "Hello World" application has no use for a <var>HildonProgram</var> object, but it
    is added to the following example (also downloadable <a href="examples/hello_world_2.py">here</a>),
    simply to illustrate how a regular Hildon application is structured.
  </p>
  <pre>
#!/usr/bin/env python2.5
import gtk
import hildon

class HelloWorldApp(hildon.Program):
  def __init__(self):
    hildon.Program.__init__(self)

    self.window = hildon.Window()
    self.window.connect("destroy", gtk.main_quit)
    self.add_window(self.window)

    label = gtk.Label("Hello World!")
    self.window.add(label)
    label.show()

  def run(self):
    self.window.show_all()
    gtk.main()

app = HelloWorldApp()
app.run()</pre>
  <p>When running the application, the result is the same as shown in Figure 3.</p>
</div>



<h2>Porting existing applications</h2>
<div class="section">
  <p>
    This section describes the issues involved in porting an existing PyGTK application to maemo.
    The porting of a real application is illustrated with step-by-step instructions.
  </p>
  <p>
    The example application is gPodder (version 0.8). It was chosen because it is reasonably
    simple, has a small, uncluttered, interface and contains most of the important issues involved
    in porting PyGTK applications to maemo.
  </p>
  <p>
    A great part of the porting effort is spent making an application use and obey the Hildon UI style
    (such as making use of hardware keys and Hildon-specific widgets). As a result, make sure that
    you are familiar with the Hildon UI style before you start porting. For more information, see
    Hildon User Interface Style Guide<a href="#references_hildon_ui_guide"><sup>2</sup></a>.
  </p>

  <h3>Installing and running gPodder in maemo</h3>
  <p>To install and run gPodder:</p>
  <ol>
    <li>
      Download the source package <a href="gpodder-0.8.0.tar.gz">here</a> or directly from the project's page,
      <var><a href="http://gpodder.berlios.de/">http://gpodder.berlios.de/</a></var>.
    </li>
    <li>
      Explode the <var>gpodder-0.8.0.tar.gz</var> file. The <var>gpodder-0.8.0</var> directory
      will be created.
    </li>
    <li>
      In the <var>gpodder-0.8.0</var> directory, use the Scratchbox console to run
      the following commands: <var>python2.5 setup.py install</var> and
      <var>run-standalone.sh gpodder</var>
    </li>
  </ol>
  <p>
    The Scratchbox console can display some GLib warnings, but you can ignore them. Figure 4
    illustrates the screen you see after running the commands:
  </p>
  <div class="screenshot">
    <img alt="gPodder running on maemo without any modifications" src="images/gpodder_1_small.jpg">
    <p>Figure 4. gPodder running on maemo without any modifications</p>
  </div>
  <p>
    This means that gPodder 0.8 works on maemo without any modifications. However, it is not a maemo
    application yet, and the steps in the following sections are required to make it fit cleanly in
    the Maemo environment.
  </p>

  <h3>gPodder code overview</h3>
  <p>
    This section gives a brief overview of gPodder's source code. The purpose of the overview is to
    make it easier to understand the code changes implemented in the following sections.
  </p>
  <p>
    Most of the code changes are made in the
    <var>gpodder-0.8.0/src/gpodder/gpodder.py</var> file. It contains the following
    classes:
  </p>
  <pre>
class Gpodder(SimpleGladeApp)
class Gpodderchannel(SimpleGladeApp)
class Gpodderproperties(SimpleGladeApp)
class Gpodderepisode(SimpleGladeApp)
class Gpoddersync(SimpleGladeApp)
class Gpodderopmllister(SimpleGladeApp)</pre>
  <p>
    Open the <var>gpodder-0.8.0/data/gpodder.glade</var> file using the
    <em><a href="http://glade.gnome.org/">Glade User Interface Designer</a></em>
    (another option is <em><a href="http://gazpacho.sicem.biz/">Gazpacho</a></em>). You can see that there is one class for each
    <var>GtkWindow</var> defined in it, as shown in Figure 5:
  </p>
  <div class="screenshot">
    <img alt="Windows defined in gPodder's glade file" src="images/gpodder_glade_1.png">
    <p>Figure 5. Windows defined in gPodder's glade file</p>
  </div>
  <p>
    In addition to loading the window description from <var>gpodder.glade</var>,
    the <var>SimpleGladeApp</var> class also makes all window elements directly
    accessible from <var>self</var>, ignoring the element's hierarchy. Figure 6
    illustrates part of the element's hierarchy for the gPodder window, and how to access the
    elements from inside a <var>Gpodder</var> method.
  </p>
  <table class="widget-code">
    <tbody>
      <tr>
        <td>
          <div class="screenshot">
            <img alt="Widget tree for the gPodder window" src="images/gpodder_glade_2.png">
            <p>Figure 6. Widget tree for the gPodder window</p>
          </div>
        </td>
        <td>
          <pre>
self.vMain
self.mainMenu
self.menuPodcasts
self.menuChannels
self.menuHelp
self.hboxContainer
self.wNotebook
self.vboxAvailablePodcasts
self.hboxChannels
self.scrollAvailable
self.treeAvailable</pre>
        </td>
      </tr>
    </tbody>
  </table>

  <h3>Changing to HildonProgram and HildonWindow</h3>
  <p>
    The first code change in the porting exercise is to make gPodder use <var>HildonProgram</var>
    and <var>HildonWindow</var> classes instead of the <var>GtkWindow</var> class.
  </p>
  <p>
    Start by modifying the <var>gpodder.py</var> file (in the <var>gpodder-0.8.0/src/gpodder</var>
    directory). Since you want to use Hildon elements, you have to import its module. The following
    example illustrates the import:
  </p>
  <pre>
61 |from libipodsync import gPodder_iPodSync
62 |from libipodsync import ipod_supported
63 |
++ |import hildon
++ |
64 |# for isDebugging:
65 |import libgpodder</pre>
  <p>
    Second, add a <var>HildonProgram</var>
    (<var>self.app</var>) and a <var>HildonWindow</var>
    (<var>self.window</var>). The following example illustrates the added
    objects:
  </p>
  <pre>
115 |        if libgpodder.isDebugging():
116 |            print "A new %s has been created" % self.__class__.__name__
117 |
 ++ |        self.app = hildon.Program()
 ++ |
 ++ |        self.window = hildon.Window()
 ++ |        self.window.set_title(self.gPodder.get_title())
 ++ |        self.app.add_window(self.window)
 ++ |
 ++ |        self.vMain.reparent(self.window)
 ++ |        self.gPodder.destroy()
 ++ |
 ++ |        self.window.show_all()
 ++ |
118 |        #self.gPodder.set_title( self.gPodder.get_title())
119 |        #self.statusLabel.set_text( "Welcome to gPodder! Suggestions? Mail to: thp@perli.net")
120 |        # set up the rendering of the comboAvailable combobox</pre>
  <p>
    The <var>gPodder</var> class (<var>self</var>) has its
    <var>close_gpodder</var> method connected to the
    <var>destroy</var> signal from the original
    <var>gPodder</var> Gtk window. This means that you have to remove the
    connection from <var>gPodder</var> and put it in the new
    <var>Hildonwindow</var> (<var>self.window</var>).
  </p>
  <p>
    To remove the signal connection from the original <var>gPodder</var> Gtk
    window, open the <var>gpodder.glade</var> file (in the
    <var>gpodder-0.8.0/data</var> directory) and remove the connection, as shown in
    Figure 7.
  </p>
  <div class="screenshot">
    <img alt="destroy signal for gPodder window" src="images/gpodder_glade_3.png">
    <p>Figure 7. destroy signal for gPodder window</p>
  </div>
  <p>
    The following example illustrates how you connect
    <var>Gpodder.close_gpodder</var> to the new
    <var>HildonProgram</var> (<var>self.app</var>):
  </p>
  <pre>
119 |
120 |        self.window = hildon.Window()
121 |        self.window.set_title(self.gPodder.get_title())
 ++ |        self.window.connect("destroy", self.close_gpodder)
122 |        self.app.add_window(self.window)
123 |
124 |        self.vMain.reparent(self.window)</pre>
  <p>
    The change from <var>GtkWindow</var> to
    <var>HildonProgram</var>/<var>HildonWindow</var> is now
    complete. Figure 8 illustrates the results if you run gPodder again.
  </p>
  <div class="note">
    <div class="label">Note</div>
    <div class="content">
      Don't forget to run <var>python2.5 setup.py install</var> before lauching gPodder again,
      otherwise you will still be using the old, unmodified, version.
    </div>
  </div>
  <div class="screenshot">
    <img alt="gPodder using HildonProgram and HildonWindow" src="images/gpodder_2_small.jpg">
    <p>Figure 8. gPodder using HildonProgram and HildonWindow</p>
  </div>
  <p>
    Note that the window fits in the screen without any broken borders, just as the "Hello World"
    application did.
  </p>

  <h3>Changing to HildonWindow menu bar</h3>
  <p>
    This section describes how you make gPodder use Hildon's title area as its menu bar, instead of
    using its own GTK+ menu (a <var>GTKMenuBar</var> object).
  </p>
  <p>
    In the <var>gpodder.glade</var> file, you can see that the
    <var>gPodder</var> window has a menu bar (a
    <var>GTKMenuBar</var> object) called <var>mainMenu</var>.
    You must move all its children (<var>menuPodcasts</var>,
    <var>menuChannels</var> and <var>menuHelp</var>) to the
    <var>HildonWindow</var>'s menu and then destroy the empty
    <var>mainMenu</var> menu.
  </p>
  <p>
    To achieve this, add the following lines to the <var>gpodder.py</var> file:
  </p>
  <pre>
125 |        self.vMain.reparent(self.window)
126 |        self.gPodder.destroy()
127 |
 ++ |        menu = gtk.Menu()
 ++ |        for child in self.mainMenu.get_children():
 ++ |            child.reparent(menu)
 ++ |        self.window.set_menu(menu)
 ++ |
 ++ |        self.mainMenu.destroy()
 ++ |
128 |        self.window.show_all()
129 |
130 |        #self.gPodder.set_title( self.gPodder.get_title())</pre>
  <p>Figure 9 illustrates the resulting menu:</p>
  <div class="screenshot">
    <img alt="gPodder using HildonWindow's menu bar" src="images/gpodder_3_small.jpg">
    <p>Figure 9. gPodder using HildonWindow's menu bar</p>
  </div>

  <h3>Using Hildon widgets</h3>
  <p>
    Hildon has a set of widgets for common operations, such as a color selection dialog, file
    chooser dialog and a time picker. Most of them provide the same functionality (or extension) as
    the existing GTK+ widgets. For example, <var>HildonFileChooserDialog</var>
    has the same purpose as <var>GtkFileChooserDialog</var>.
  </p>
  <p>
    Replace the GTK+ widgets with the Hildon ones whenever possible, since the Hildon widgets were
    designed to obey maemo's restrictions and peculiarities.
  </p>
  <p>
    gPodder uses a GTK+ file chooser dialog when users export their channel lists. It doesn't fit
    well into maemo's environment as you can see from Figure 10.
  </p>
  <div class="screenshot">
    <img alt="gPodder using GTK's file chooser dialog" src="images/gpodder_4_small.jpg">
    <p>Figure 10. gPodder using GTK's file chooser dialog</p>
  </div>
  <p>
    Make it use a <var>HildonFileChooserDialog</var> instead. The following example illustrates the
    code changes needed in <var>gpodder-0.8.0/src/gpodder/gpodder.py</var>:
  </p>
  <pre>
579    |        if len( self.channels) == 0:
580    |          self.showMessage( _("Your channel list is empty. Nothing to export."))
581    |          return
582 -- |        dlg = gtk.FileChooserDialog( title=_("Export to OPML"), parent = None,[...]
583 -- |        dlg.add_button( gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
584 -- |        dlg.add_button( gtk.STOCK_SAVE, gtk.RESPONSE_OK)
    ++ |        dlg = hildon.FileChooserDialog(self.window, gtk.FILE_CHOOSER_ACTION_SAVE);
585    |        response = dlg.run()
586    |        if response == gtk.RESPONSE_OK:
587    |            foutname = dlg.get_filename()</pre>
  <p>Figure 11 illustrates the results when you select <em>Menu &gt; Channels &gt; Export List</em>:</p>
  <div class="screenshot">
    <img alt="gPodder using Hildon's file chooser dialog" src="images/gpodder_5_small.jpg">
    <p>Figure 11. gPodder using Hildon's file chooser dialog</p>
  </div>

  <h3>Adjusting the Glade interface to fit into a small screen</h3>
  <p>
    The following change to the interface layout is necessary to make it fit into the relatively
    small maemo screen:
  </p>
  <ul>
    <li>
      Main window (<var>gPodder</var>)
      <p>
        Make the tab names shorter. Replace &ldquo;<em>Downloaded Podcasts</em>&rdquo; with
        &ldquo;<em>Downloaded</em>&rdquo; and &ldquo;<em>Available Podcasts</em>&rdquo; with
        &ldquo;<em>Podcasts</em>&rdquo; to make the tab names stay within screen boundaries.
        Figure 12 shows the tab names before (left) and after (right) that change.
      </p>
      <div class="twin-screenshot">
          <img alt="gPodder with shortened tab names" src="images/gpodder_6_small.jpg">
          <p>Figure 12. gPodder with its original (left) and shortened (right) tab names</p>
      </div>
    </li>
  </ul>

  <h3>Using hardware keys</h3>
  <p>
    Maemo applications must use the available hardware keys to improve their usability. Most
    applications don't have use for of them, of course, but try nonetheless to use those
    that make sense in your program, giving it the usability expected from a proper maemo
    application.
  </p>
  <p>
    The <em>Full screen</em> hardware key is particularly useful, since the screen size is one of
    the key issues in maemo applications, especially in desktop applications that are being
    ported to maemo (such as gPodder).
  </p>
  <p>To implement the full screen functionality, you have to monitor two more window signals:</p>
  <ul>
    <li>Key presses, to know when the <em>Full screen</em> key is pressed.</li>
    <li>Window state changes, to know whether the window is already in full screen mode.</li>
  </ul>
  <p>
    To make gPodder respond correctly when the user presses the <var>Full screen</var> hardware key
    you have to make the following changes to <var>gpodder-0.8.0/src/gpodder/gpodder.py</var>:
  </p>
  <p>
     1. Connect to the signals and set a variable to monitor whether the application is
     in full screen mode.
  </p>
  <pre>
120 |        self.window = hildon.Window()
121 |        self.window.set_title(self.gPodder.get_title())
122 |        self.window.connect("destroy", self.close_gpodder)
 ++ |        self.window.connect("key-press-event", self.on_key_press)
 ++ |        self.window.connect("window-state-event", self.on_window_state_change)
 ++ |        self.window_in_fullscreen = False #The window isn't in full screen mode initially.
123 |        self.app.add_window(self.window)
124 |
125 |        self.vMain.reparent(self.window)</pre>
  <p>
    2. Implement the callback to monitor window state changes.
  </p>
  <pre>
575 |            self.showMessage( _("Could not delete channel.\nProbably no channel is selected."))
576 |    #-- Gpodder.on_itemRemoveChannel_activate }
577 |
 ++ |    def on_window_state_change(self, widget, event, *args):
 ++ |        if event.new_window_state &amp; gtk.gdk.WINDOW_STATE_FULLSCREEN:
 ++ |            self.window_in_fullscreen = True
 ++ |        else:
 ++ |            self.window_in_fullscreen = False
 ++ |
578 |    #-- Gpodder.on_itemExportChannels_activate {
579 |    def on_itemExportChannels_activate(self, widget, *args):
580 |        if libgpodder.isDebugging():</pre>
  <p>
    3. Implement the callback to monitor key presses.
  </p>
  <pre>
581 |        else:
582 |            self.window_in_fullscreen = False
583 |
 ++ |    def on_key_press(self, widget, event, *args):
 ++ |        if event.keyval == gtk.keysyms.F6:
 ++ |            # The "Full screen" hardware key has been pressed
 ++ |            if self.window_in_fullscreen:
 ++ |                self.window.unfullscreen ()
 ++ |            else:
 ++ |                self.window.fullscreen ()
 ++ |
584 |    #-- Gpodder.on_itemExportChannels_activate {
585 |    def on_itemExportChannels_activate(self, widget, *args):
586 |        if libgpodder.isDebugging():</pre>
  <div class="frame note">
    <div class="label">Note</div>
    <div class="content">The <em>Full screen</em> hardware key maps to the F6 key on the SDK.</div>
  </div>
  <p>Figure 13 illustrates gPodder in full screen mode.</p>
  <div class="screenshot">
    <img alt="gPodder in full screen mode" src="images/gpodder_7_small.jpg">
    <p>Figure 13. gPodder in full screen mode</p>
  </div>
</div>



<h2>Introduction to LibOSSO</h2>
<div class="section">
  <p>
    LibOSSO is the basic library containing required and helpful functions for maemo applications.
    One of LibOSSO's main features is RPC (Remote Procedure Calls) services (as it "wraps" D-Bus
    <a href="#references_maemo_sdk_tutorial"><sup>3</sup></a>). In addition, LibOSSO provides access
    to low-level hardware functions, such as turning on (or keeping on) the display, autosaving,
    state saving and system time.
  </p>
  <p>
    All maemo-compliant applications must use LibOSSO to respond coherently to system changes and
    signals, such as the battery low, pre-shutdown and state saving signals.
  </p>
  <p>
    This section describes how remote procedure calls are implemented using LibOSSO. The example is
    divided in two different sample applications: <var>osso_test_sender.py</var>
    and <var>osso_test_receiver.py</var>.
  </p>
  <p>
    The sender sample application sends an RPC message when a button is clicked. D-Bus interprets
    the message and sends the RPC to the receiver sample application, which displays a system
    notification stating that it has received the RPC.
  </p>

  <h3>Sender sample application</h3>
  <p>
    The sender is simply a button occupying the whole window. When you click it, an RPC is sent to
    the receiver sample application.
  </p>
  <p>Create a <var>osso_test_sender.py</var> file with the following content.</p>
  <pre>
#!/usr/bin/python2.5
import osso
import hildon
import gtk

def send_rpc(widget, osso_c):
    osso_rpc = osso.Rpc(osso_c)
    osso_rpc.rpc_run("spam.eggs.osso_test_receiver",
        "/spam/eggs/osso_test_receiver",
        "spam.eggs.osso_test_receiver", "do_something")
    print "RPC sent"

osso_c = osso.Context("osso_test_sender", "0.0.1", False)
window = hildon.Window()
window.connect("destroy", gtk.main_quit)
send_button = gtk.Button("Send RPC")
window.add(send_button)
send_button.connect("clicked", send_rpc, osso_c)
window.show_all()
gtk.main()</pre>

  <h3>Receiver sample application</h3>
  <p>
    The receiver is an application that has no GUI (no window), it runs unseen in the background
    waiting for an RPC. When it receives one, it uses LibOSSO to display an information banner
    notifying the user that an RPC has been received.
  </p>
  <p>Create a <var>osso_test_receiver.py</var> file with the following content.</p>
  <pre>
#!/usr/bin/python2.5
import osso
import gtk

def callback_func(interface, method, arguments, user_data):
    print "RPC received"
    osso_c = user_data
    osso_sysnote = osso.SystemNote(osso_c)
    osso_sysnote.system_note_infoprint("osso_test_receiver: Received an RPC to %s." % method)

osso_c = osso.Context("osso_test_receiver", "0.0.1", False)
print "osso_test_receiver started"
osso_rpc = osso.Rpc(osso_c)
osso_rpc.set_rpc_callback("spam.eggs.osso_test_receiver",
    "/spam/eggs/osso_test_receiver",
    "spam.eggs.osso_test_receiver", callback_func, osso_c)
gtk.main()</pre>
  <p>
    The receiver also must register itself as a D-Bus service. Create a
    <var>osso_test_receiver.service</var> file with the following content.
  </p>
  <pre>
[D-BUS Service]
Name=spam.eggs.osso_test_receiver
Exec={SOME_DIRECTORY_HIERARCHY}/osso_test_receiver.py</pre>
  <p>
    Replace <var>{SOME_DIRECTORY_HIERARCHY}</var> with the directory where
    <var>osso_test_receiver.py</var> is located.</p>
  <p>
    Add the <var>osso_test_receiver.service</var> file to
    <var>/usr/share/dbus-1/services</var>.
  </p>

  <h3>Running applications</h3>
  <p>
    First make sure that D-Bus recognises the new D-Bus service (
    <var>spam.eggs.osso_test_receiver</var>). To do this, restart your maemo
    environment by using the following command on the Scratchbox console:
  </p>
  <pre>[sbox-TARGET_NAME: ~] &gt; af-sb-init.sh restart</pre>
  <p>
    Then run <var>osso_test_sender.py</var> with the following command (assuming
    that it is in your home directory):
  </p>
  <pre>[sbox-TARGET_NAME: ~] &gt; run-standalone.sh ./osso_test_sender.py</pre>
  <p>Figure 12 illustrates what now happens every time you click the <em>Send RPC</em> button.</p>
  <div class="screenshot">
    <img alt="LibOSSO sample application" src="images/libosso_tutorial_small.jpg">
    <p>Figure 12. LibOSSO sample application</p>
  </div>
  <p>
    Note that you do not have to manually run <var>osso_test_receiver.py</var>,
    as D-Bus does it automatically. Due to its extreme simplicity, the once instantiated
    <var>osso_test_receiver.py</var> continues running in background until you
    manually kill it from the Scratchbox console.
  </p>
</div>



<h2>Distributing the Python applications</h2>
<div class="section">
  <p>
    To distribute applications, you must put it in a neat single file (such as a regular Debian
    package) so that the application installer can recognise and install it, put all files to their
    correct locations and create an entry for the application in the menu.
  </p>

  <h3>Requirements</h3>
  <p>
    As maemo devices are not delivered with Python by default, the maemo Python runtime package must
    also be installed. You can download it from <a href="http://www.maemo.org/">http://www.maemo.org</a>.
  </p>

  <h3>Distributing a "Hello PyMaemo!" application</h3>
  <p>
    This section describes the process of creating a maemo package by showing how to package a
    simple "hello world" style application. Create a <var>hello-pymaemo</var>
    file (without the "<var>.py</var>" suffix) with the following content.
  </p>
  <pre>
#!/usr/bin/env python2.5

import gtk
import hildon
import osso

osso_c = osso.Context("hello_pymaemo", "1.0.0", False)
window = hildon.Window ()
window.set_title ("Hello maemo!")
window.connect("destroy", gtk.main_quit)

button = gtk.Button ("Hello Python for Maemo!")
window.add (button)

window.show_all ()
gtk.main ()</pre>
  <p>
    Make the file executable by running the <var>chmod +x hello-pymaemo</var>
    command. This ensures that you can run the script in the same way as a regular binary
    application.
  </p>

  <h4>Desktop integration</h4>
  <p>
    You must have an icon for the application. The icon is shown in the menu entry and in the task
    navigator bar. The icon must be a 26x26 pixels PNG image with a transparent background, such as
    the <a href="http://www.maemo.org/platform/docs/python-bora/images/pymaemo_bora/hello_icon_26x26.png">
    example icon</a> shown in Figure 13:
  </p>
  <div class="screenshot">
    <img alt="Hello PyMaemo icon" src="images/hello_icon_26x26.jpg">
    <p>Figure 13. Hello PyMaemo icon</p>
  </div>
  <p>Name the icon <var>hello_icon_26x26.png</var>.</p>
  <p>
    The menu entry is a <var>.desktop</var> file with the following content for
    the application:
  </p>
  <pre>
[Desktop Entry]
Version=1.0.0
Encoding=UTF-8
Name=Hello PyMaemo!
Exec=/usr/bin/hello-pymaemo
Icon=hello_icon_26x26
Type=Application
X-Osso-Service=hello_pymaemo
X-Osso-Type=application/x-executable</pre>
  <div class="frame note">
    <div class="label">Note</div>
    <div class="content">
      Be very careful when writing the desktop file, since the system is very sensitive to
      typographical errors in it and a faulty desktop file simply fails to show its menu entry
      without yielding any errors.
    </div>
  </div>
  <table border="0" cellpadding="4" cellspacing="1">
    <tbody>
      <tr>
        <th colspan="1" rowspan="1">Field name</th>
        <th colspan="1" rowspan="1">Description</th>
      </tr>
      <tr>
        <td colspan="1" rowspan="1"><var>Version</var></td>
        <td colspan="1" rowspan="1">Application version</td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1"><var>Encoding</var></td>
        <td colspan="1" rowspan="1">Character encoding. Must always be <var>UTF8</var>.</td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1"><var>Name</var></td>
        <td colspan="1" rowspan="1">Application's name</td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1"><var>Exec</var></td>
        <td colspan="1" rowspan="1">File to be executed when the application is called</td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1"><var>Icon</var></td>
        <td colspan="1" rowspan="1">
          Application's icon. Only the name of the file <strong>without</strong> its suffix
          (<var>.png</var>).
        </td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1"><var>Type</var></td>
        <td colspan="1" rowspan="1">
          "<var>Application</var>"since it is an entry for an application
        </td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1"><var>X-Osso-Service</var></td>
        <td colspan="1" rowspan="1">
          Name of the osso service that calls this application. For more information, see the
          paragraphs below the table.
        </td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1"><var>X-Osso-Type</var></td>
        <td colspan="1" rowspan="1">Usually "<var>application/x-executable</var>"</td>
      </tr>
    </tbody>
  </table>
  <p>Table 1. <var>.desktop</var> file fields</p>
  <p>
    As you can see in the desktop file, the application also needs an osso (D-Bus) service.
    Otherwise, it does not appear in the task navigation bar. For the service, create a
    <var>hello_pymaemo.service</var> file with the following content.
  </p>
  <pre>
[D-BUS Service]
Name=com.nokia.hello_pymaemo
Exec=/usr/bin/hello-pymaemo</pre>
  <p>
    Note that since "-" is not a valid character in a service name.,
    <var>hello_pymaemo</var> is used instead of
    <var>hello-pymaemo</var>.
  </p>

  <h4>Copying files to their locations</h4>
  <p>
    Use Python Distribution Utilities ("Distutils") to copy the files to their proper locations.
    Create a <var>setup.py</var> file with the following content.
  </p>
  <pre>
from distutils.core import setup

setup(name='hello-pymaemo',
       version='1.0.0',
       scripts=['hello-pymaemo'],
       data_files = [
                    ('share/pixmaps',             ['hello_icon_26x26.png']),
                    ('share/applications/hildon', ['hello-pymaemo.desktop']),
                    ('share/dbus-1/services',     ['hello_pymaemo.service']),
                    ]
      )</pre>
  <p>
    In the Scratchbox console, issue the <var>python2.5 setup.py install</var>
    command to achieve the following result:
  </p>
  <ul>
    <li>
      <var>hello-pymaemo</var> is copied to <var>/usr/bin</var>
    </li>
    <li>
      <var>hello_icon_26x26.png</var> is
      copied to <var>/usr/share/pixmaps</var>
    </li>
    <li>
      <var>hello-pymaemo.desktop</var> is
      copied to <var>/usr/share/applications/hildon</var>
    </li>
    <li>
      <var>hello_pymaemo.service</var> is
      copied to <var>/usr/share/dbus-1/services</var>
    </li>
  </ul>
  <p>
    After you have run the command, the application is actually installed in your system (in
    Scratchbox, you have to ru the <var>af-sb-init.sh restart</var> command
    before calling your application from the menu). You can access it from the <em>Extras</em> menu.
  </p>
  <p>
    The problem with this approach is that if you want to remove the application, you have to
    manually delete every file from its corresponding directory, which is not practical. It is also
    not practical to distribute an application this way, since every user has to manually run the
    command (or a script that does it).
  </p>
  <p>
    Instead, you can let the Application Installer take care of all these issues. To do that, you
    have to group all the files in a Debian package.
  </p>
  <p>
    For more information about Python Distribution Utilities, see Distributing Python
    Modules<a href="#references_python_distutils"><sup>4</sup></a>. To get a basic knowledge of
    Distutils, reading Chapters 1 and 2 is strongly recommended.
  </p>

  <h4>Creating a Debian package</h4>
  <p>
    When creating a Debian package, the first step is to put all the files (the hello-pymaemo script,
    and the png, desktop and service files) in an empty directory called
    <var>hello-pymaemo-1.0.0</var>. The directory name must follow the
    <var>&lt;package-name&gt;-&lt;app-version&gt;</var> convention. This means
    that the package that you are creating for the hello world application is called
    <var>hello-pymaemo</var>.
  </p>
  <p>
    As Debian packages use makefiles (<var>Makefile</var>) instead of Python
    Distutils (<var>setup.py</var>), you have to write a
    <var>Makefile</var> to act as an interface between the Debian package system
    and the <var>setup.py</var>. The file is very simple; it merely issues
    commands to <var>setup.py</var> according to make's target. If you have no
    knowledge of make files, see Chapters 1 and 2 in GNU Make
    Manual<a href="#references_make"><sup>5</sup></a>.
  </p>
  <p>Create a <var>Makefile</var> file with the following content.</p>
  <pre>
all:
  python2.5 setup.py build
clean: 
  python2.5 setup.py clean --all
install:
  python2.5 setup.py install --root $(DESTDIR)</pre>
  <p>
    In Scratchbox console (inside the <var>hello-pymaemo-1.0.0</var> directory),
    enter the following command:
  </p>
  <pre>[sbox-TARGET_NAME: ~/hello-pymaemo-1.0.0] &gt; dh_make -e your.email@somewhere.com</pre>
  <p>The system displays the following output:</p>
  <pre>
Type of package: single binary, multiple binary, library, or kernel module?  [s/m/l/k] s
Maintainer name : unknown
Email-Address   : your.email@somewhere.com
Date            : Thu, 18 May 2006 13:58:04 -0300
Package Name    : hello-pymaemo
Version         : 1.0.0
Type of Package : Single
Hit &lt;enter&gt; to confirm:
Done. Please edit the files in the debian/ subdirectory now.
You should also check that the hello-pymaemo Makefiles install into $DESTDIR and not in / .</pre>
  <p>
    Choose "single binary" as a package type. In case the <var>"--root $(DESTDIR)"
    </var> part of the makefile is not clear to you, the last sentece in the output is meant to
    clarify the situation.
  </p>
  <p>
    The <var>dh_make</var> command creates a <var>debian</var>
    subdirectory containing multiple configuration text files, most of which are templates that can
    be removed, since the application does not use them. In addition, the command makes a copy of
    the original directory, calling it <var>hello-pymaemo-1.0.0.orig</var>.
  </p>
  <p>
    Table 2 lists the files needed in <var>hello-pymaemo-1.0.0/debian</var>
    (others can be removed):
  </p>
  <p>Table 2. Needed files for the example application package</p>
  <table class="ForrestTable" border="0" cellpadding="4" cellspacing="1">
    <tbody>
      <tr>
        <th colspan="1" rowspan="1">File in <var>./debian</var></th>
        <th colspan="1" rowspan="1">Description</th>
      </tr>
      <tr>
        <td colspan="1" rowspan="1">changelog</td>
        <td colspan="1" rowspan="1">Application's change log</td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1">compat</td>
        <td colspan="1" rowspan="1">Debian helper compatibily version. Leave it as it is.</td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1">control</td>
        <td colspan="1" rowspan="1">
          Describes the packages to be made. For more information, see the paragraphs
          below the table.
        </td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1">copyright</td>
        <td colspan="1" rowspan="1">Copyright text. Fill in the blanks.</td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1">rules</td>
        <td colspan="1" rowspan="1">
          A makefile containing the rules to build all kinds of packages (such as source and binary).
          For more information, see the paragraphs below the table.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    The key files in <var>./debian</var> are <var>control</var>
    and <var>rules</var>. They contain a generic template showing what they must
    look like. In <var>control</var>, you must simply fill in the blanks and, in
    <var>rules</var>, you essentially need to remove unwanted and unnecessary
    code.
  </p>
  <p>
    The following example illustrates what the <var>control</var> file for the
    example application must contain:
  </p>
  <pre>
Source: hello-pymaemo
Section: user/other
Priority: optional
Maintainer: My Name &lt;your.email@somewhere.com&gt;
Build-Depends: debhelper (&gt;= 4.0.0), python2.5-dev
Standards-Version: 3.6.0

Package: hello-pymaemo
Architecture: all
Depends: python2.5, python2.5-hildon, python2.5-gtk2
Description: A simple "Hello Python for Maemo!"
 A very simple application consisting of a single button, containing the
 text "Hello Python for Maemo!".
XB-Maemo-Icon-26:
 iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAABmJLR0QA/wD/AP+g
 vaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH1gURDQoYya0JlwAAAU9J 
 REFUSMftlL1KA0EUhb/NZl/ggnHQxsJUxt5CUucVJCCkDfgyKdIGG5/A0s5HEBtJ
 EdDAQGBgmw0YJmMzgXXYza5CtNkDW9zZw5z7c+ZCgwb/Ai3i9sVl/Bq8RIs4LRK1 
 gJDsKvJyNXmJMuYTsMoY1zpgozaABdYArQNPZQ1kfyGU7SpqVwxzAMwABWhgpIwp
 4vWBB+AUWAI3ypjnfEXtPU4bLKx9vErTeCeiRSYF+fTn1j5dp2myE9EiU+DSi3wX 
 ymeqRQAmZ3EcA5E/fgO6BULT8zhOcrwXoJdrXRa2Lgps2y2odAUcBUIXQdz78YyC
 SldAp8b7+bXrIv91qjZBietqCc2DjbAt4b2WxJkyZljVujlwp0U0cPxuLcAIuC+4 
 dKxFlsDJarvdAGP/b6hFnDImYs+uG3hbO2AB3Jbsur63tQM+fFx3bzZocEB8AdV2
 gJBZgKTwAAAAAElFTkSuQmCC</pre>
  <p>
    The <var>XB-Maemo-Icon-26</var> field contains the application icon file (in
    this case, <var>hello_icon_26x26.png</var>) encoded in base64. This is the
    icon that is shown in the Application Installer, next to the package name. To do this encoding
    in Linux, you can use either <var>uuencode</var> or <var>
    openssl</var> (there can be more suitable applications). Maemos's Scratchbox rootstrap is
    delivered with <var>uuencode</var>. Do not forget to put a white space at the
    beginning of each line containing the icon-encoded text. The white space serves as indentation.
    The same rule stands for the long package description (<var> A very simple
    application[...]</var>).
  </p>
  <p>
    The Application Installer only shows packages in the <var>user</var> section.
    Thus, your <var>Section:</var> field in the <var>control
    </var> file must has the <var>Section: user/&lt;SUBSECTION&gt;</var> syntax,
    where <var>&lt;SUBSECTION&gt;</var> is arbitrary.
  </p>
  <p>
    The following example illustrates the <var>rules</var> file for the example
    application:
  </p>
  <pre>
#!/usr/bin/make -f
# -*- makefile -*-
# Sample debian/rules that uses debhelper.
# GNU copyright 1997 to 1999 by Joey Hess.

# Uncomment this to turn on verbose mode.
#export DH_VERBOSE=1

ifeq (,$(findstring nostrip,$(DEB_BUILD_OPTIONS)))
 	INSTALL_PROGRAM += -s
endif

configure: configure-stamp

configure-stamp:
	dh_testdir
 	# Add here commands to configure the package.

	touch configure-stamp
build: build-stamp

build-stamp: configure-stamp 
	dh_testdir
 	# Add here commands to compile the package.
	$(MAKE)

	touch build-stamp

clean: 	dh_testdir
	dh_testroot
	rm -f build-stamp configure-stamp

	# Add here commands to clean up after the build process.
	-$(MAKE) clean

	dh_clean

install: build
	dh_testdir
	dh_testroot
	dh_clean -k
 	dh_installdirs

	# Add here commands to install the package into debian/hello-pymaemo.
	$(MAKE) install DESTDIR=$(CURDIR)/debian/hello-pymaemo

# Build architecture-independent files here.

binary-indep: build install
	dh_testdir
	dh_testroot
	dh_installchangelogs
 	dh_fixperms
	dh_installdeb
	dh_gencontrol
	dh_md5sums
	dh_builddeb

binary-arch: build install

binary: binary-indep binary-arch
.PHONY: build clean binary-indep binary-arch binary install configure</pre>
  <p>
    The main point is that the <var>binary-arch</var> target was emptied and the
    <var>binary-indep</var> filled, since the application being 100% Python means
    that it is 100% architecture-independent.
  </p>
  <p>
    All the preliminary steps are now done, and you can build the Debian package itself with the
    following command:
  </p>
  <pre>[sbox-TARGET_NAME: ~/hello-pymaemo-1.0.0] &gt; dpkg-buildpackage -rfakeroot</pre>
  <p>
    The system displays some output, including a couple of warnings near the end of it
    (about XB-Maemo-Icon-26) but that is normal. The parent directory now has a <var>
    hello-pymaemo_1.0.0-1_all.deb</var> file - your Debian package. This is the file that is
    distributed to maemo devices and installed using the Application Installer.
  </p>
  <p>
    For more information about making Debian packages, see Debian New Maintainers'
    Guide<a href="#references_debian"><sup>6</sup></a>.
  </p>
</div>



<h2>References</h2>
<div class="section">
  <p>
    <a name="references_maemo_sdk_tutorial"></a>
    <strong>[1]</strong>
    Maemo 3.0 Tutorial:
    <a href="http://www.maemo.org/platform/docs/howtos/Maemo_tutorial_bora.html">http://www.maemo.org/platform/docs/howtos/Maemo_tutorial_bora.html</a>
  </p>
  <p>
    <a name="references_hildon_ui_guide"></a>
    <strong>[2]</strong>
    Hildon User Interface Style Guide (version 1.0):
    <a href="http://www.maemo.org/community/UI_Style_Guide_Summary_1.0.pdf">http://www.maemo.org/community/UI_Style_Guide_Summary_1.0.pdf</a>
  </p>
  <p>
    <a name="references_dbus"></a>
    <strong>[3]</strong>
    D-Bus:
    <a href="http://www.freedesktop.org/wiki/Software/dbus">http://www.freedesktop.org/wiki/Software/dbus</a>
  </p>
  <p>
    <a name="references_python_distutils"></a>
    <strong>[4]</strong>
    Distributing Python Modules:
    <a href="http://docs.python.org/dist/dist.html">http://docs.python.org/dist/dist.html</a>
  </p>
  <p>
    <a name="references_make"></a>
    <strong>[5]</strong>
    GNU Make Manual:
    <a href="http://www.gnu.org/software/make/manual/">http://www.gnu.org/software/make/manual/</a>
  </p>
  <p>
    <a name="references_debian"></a>
    <strong>[6]</strong>
    Debian New Maintainers' Guide:
    <a href="http://www.us.debian.org/doc/maint-guide/">http://www.us.debian.org/doc/maint-guide/</a>
  </p>
</div>


</body>
</html>